
#' Get UniProt Protein Info (GUPPI)
#'
#' @description
#' guppi() analyzes a .tdReport file generated by TDPortal or ProSightPD and adds 
#' additional data from UniProt.
#' 
#' @param filedir Character vector of the directory which contains the input file(s). Files can be at 
#' any level below the directory, subdirectories are checked recursively.
#' @param filename Character vector of the names of the tdReport files, including extension. 
#' Must match the name of the files exactly.
#' @param taxonNumber Numeric vector. NCBI taxon number to be used for getting UniProt data, 
#' e.g. 83333 for E. coli K12.
#' @param GOLocType Name of taxon to use for determination of subcellular locations. 
#' Acceptable values are "bacteria" and "eukaryota".
#' @param fractionAssignments Optional argument. A named list with names set to 
#' the fraction numbers of the input files and values set to the input file names. 
#' If left blank, GUPPI will attempt to assign fraction numbers automatically from 
#' file names in the tdReport.
#' @param outputdir Character vector. Directory to use for output, files will be 
#' saved to subdirectories. Directory will be created if it doesn't exist, as long 
#' as parent directory exists.
#' @param fdr False detection rate cutoff for protein and proteoform identifications. 
#' Defaults to 0.01 (1\%).
#' @param saveOutput Boolean value. Controls whether protein report, proteoform 
#' report, etc. are saved to output directory. Doesn't effect GUPPI report. 
#' Defaults to TRUE.
#' @param makeDashboard Boolean value. Controls whether GUPPI report is rendered 
#' to the output directory. Defaults to FALSE.
#' @param staticDashboard Boolean value. Controls whether the dashboard should be
#' generated with dynamic visualization based on Plotly or with static images.
#' @param dashboardPath Full path and name of dashboard output (i.e. GUPPI report). 
#' Defaults to /report subdirectory of the output directory.
#' 
#' @return
#' This function is called for its side effects, i.e. the files in the output
#' directory.
#'
#' @export
#'
#' @examples
#' \dontrun{
#'     GUPPI::guppi(
#'        "C:/Users/David Butcher/TDReports",
#'        c(
#'           "20200420_Excellent_TDReport_01.tdReport",
#'           "20200420_Excellent_TDReport_02.tdReport"
#'        ),
#'        83333,
#'        GOLocType = "bacteria",
#'        fractionAssignments = NULL,
#'        outputdir = "C:/Users/David Butcher/guppi_output",
#'        fdr = 0.01,
#'        saveOutput = TRUE,
#'        makeDashboard = TRUE
#'     )
#' }

guppi <-
   function(
      filedir,
      filename,
      taxonNumber,
      GOLocType = "bacteria",
      fractionAssignments = NULL,
      outputdir,
      fdr = 0.01,
      saveOutput = TRUE,
      makeDashboard = FALSE,
      staticDashboard = FALSE,
      dashboardPath = glue::glue(
         "{outputdir}/report/{format(Sys.time(), '%Y%m%d_%H%M%S')}_dashboard.html"
      )
   ) {
      
      # Assertions --------------------------------------------------------------
      
      assertthat::assert_that(
         assertthat::is.dir(filedir),
         msg = "filedir is not a recognized path"
      )
      
      purrr::map_chr(
         filename,
         ~assertthat::assert_that(
            assertthat::is.string(.x),
            msg = "A filename is not a string"
         )
      )
      
      assertthat::assert_that(
         assertthat::is.number(taxonNumber),
         msg = "taxonNumber is not a number"
      )
      
      assertthat::assert_that(
         GOLocType == "bacteria" | GOLocType == "eukaryota",
         msg = "GOLocType must be 'bacteria' or 'eukaryota'"
      )
      
      assertthat::assert_that(
         assertthat::is.dir(dirname(outputdir)),
         msg = "outputdir parent is not a recognized path"
      )
      
      assertthat::assert_that(
         assertthat::is.number(fdr) & fdr > 0 & fdr <= 1,
         msg = "fdr should be a number between 0 and 1"
      )
      
      assertthat::assert_that(
         assertthat::is.flag(makeDashboard),
         msg = "makeDashboard should be TRUE or FALSE"
      )
      
      assertthat::assert_that(
         assertthat::is.flag(staticDashboard),
         msg = "staticDashboard should be TRUE or FALSE"
      )
      
      # if (makeDashboard == TRUE) {
      #    assertthat::assert_that(
      #       assertthat::is.dir(outputDir),
      #       msg = "dashboardPath parent is not a recognized path"
      #    )
      # }
      
      
      
      ## Check file extensions ------------------------------------------------
      
      fileList <-
         get_data_path(
            filedir,
            filename,
            fs::path_ext(filename)
         )
      
      fileExtension <-
         purrr::map(
            fileList,
            ~tolower(fs::path_ext(.x))
         )
      
      # assertthat::assert_that(
      #    assertthat::assert_that(
      #       length(unique(extension)) <= 1
      #    ),
      #    msg = "More than one file extension present. Only one type of file is allowed."
      # )
      
      assertthat::assert_that(
         assertthat::assert_that(
            length(fileExtension) != 0
         ),
         msg = "No acceptable input files. Only tdReport, csv, or xlsx are allowed."
      )
      
      # Check for allowed extensions, case insensitive
      
      allowed_extensions <- c("tdreport", "csv", "tsv", "xlsx")
      
      assertthat::assert_that(
         purrr::map_chr(
            fileExtension,
            ~stringr::str_detect(
               .x, stringr::fixed(allowed_extensions, ignore_case = TRUE)
            ) %>% 
               any()
         ) %>% 
            as.logical() %>% 
            all(),
         msg = 
            paste0(
               "All extensions must be one of",
               paste(allowed_extensions, collapse = ", ")
            )
      )
      
      # Load input files --------------------------------------------------------
      
      # Start timer
      
      tictoc::tic()
      
      ## Load/download UniProt database ------------------------------------------
      
      # Check for predownloaded UP database
      
      if (
         file.exists(
            system.file(
               "extdata",
               "UPdatabase",
               paste0(taxonNumber, "_full_UniProt_database.rds"),
               package = "GUPPI"
            )
         )
      ) {
         
         message(
            glue::glue(
               "\nLoading UniProt database for taxon {taxonNumber} from package directory"
            )
         )
         
         UPdatabase <-
            readRDS(
               system.file(
                  "extdata",
                  "UPdatabase",
                  paste0(taxonNumber, "_full_UniProt_database.rds"),
                  package = "GUPPI"
               )
            )
         
      } else {
         
         UPdatabase <-
            download_UP_database(
               taxonNumber,
               saveUPdata = TRUE
            )
         
      }
      
      
      ## Load GO locations correlation table -------------------------------------
      
      # Load file containing locations corresponding to
      # GO terms, either bacteria or eukaryota
      
      if (GOLocType == "bacteria") {
         
         go_locs_table <-
            read.csv(
               system.file(
                  "extdata",
                  "GO_cellular_component_taxon2_bacteria.csv",
                  package = "GUPPI"
               )
            )
         
      } else if (GOLocType == "eukaryota") {
         
         go_locs_table <-
            read.csv(
               system.file(
                  "extdata",
                  "GO_cellular_component_taxon2759_eukaryota.csv",
                  package = "GUPPI"
               )
            )
         
      }
      
      
      ## Load modifications data ----------------------------------------------
      
      # Load file containing all the PTM information from TDreport
      # (sourced from UniMod, PSI-MOD, etc.)
      
      tdreport_mods <-
         readRDS(
            system.file(
               "extdata",
               "tdreport_mods_table.rds",
               package = "GUPPI"
            )
         )
      
      # Run analysis ---------------------------------------------------------------------------------
      
      # Save start time to variable for use in output filenames
      
      systime <- format(Sys.time(), "%Y%m%d_%H%M%S")
      
      ## Read Data Files -----------------------------------------------------------------------------
      
      # Determine software of origin
      
      fileType <- 
         purrr::map(
            fileList,
            determine_software
         )
      
      
      # Get raw results separately for protein, protein_full (tdreport only),
      # and proteoforms
      
      # Raw results, protein
      
      raw_results_protein <- 
         purrr::pmap(
            list(
               fileType,
               fileList,
               fileExtension
            ),
            ~switch(
               ..1,
               "tdreport" = 
                  read_tdreport_protein(..2),
               "accessionlist" = 
                  switch(
                     ..3,
                     "tsv" = readr::read_tsv(..2),
                     "csv" = readr::read_csv(..2),
                     "xlsx" = readxl::read_xlsx(..2)
                  ),
               "toppic" = 
                  switch(
                     ..3,
                     "tsv" = readr::read_tsv(..2, skip = toppic_lines_to_skip(..2)),
                     "csv" = readr::read_csv(..2, skip = toppic_lines_to_skip(..2)),
                     "xlsx" = readxl::read_xlsx(..2, skip = toppic_lines_to_skip(..2))
                  ),
               "mspathfinder" = 
                  switch(
                     ..3,
                     "tsv" = readr::read_tsv(..2),
                     "csv" = readr::read_csv(..2),
                     "xlsx" = readxl::read_xlsx(..2)
                  ),
               "unknown" = NA
            )
         ) %>% 
         purrr::set_names(fileList)
      
      # Raw results, protein full
      
      raw_results_protein_full <- 
         purrr::pmap(
            list(
               fileType,
               fileList,
               fileExtension
            ),
            ~switch(
               ..1,
               "tdreport" = 
                  read_tdreport_protein_full(..2),
               "accessionlist" = NA,
               "toppic" = NA,
               "mspathfinder" = NA,
               "unknown" = NA
            )
         ) %>% 
         purrr::set_names(fileList)
      
      # Raw results, proteoform
      
      raw_results_proteoform <- 
         purrr::pmap(
            list(
               fileType,
               fileList,
               fileExtension
            ),
            ~switch(
               ..1,
               "tdreport" = 
                  read_tdreport_proteoform(..2),
               "accessionlist" = 
                  NA,
               "toppic" = 
                  switch(
                     ..3,
                     "tsv" = readr::read_tsv(..2, skip = toppic_lines_to_skip(..2)),
                     "csv" = readr::read_csv(..2, skip = toppic_lines_to_skip(..2)),
                     "xlsx" = readxl::read_xlsx(..2, skip = toppic_lines_to_skip(..2))
                  ),
               "mspathfinder" = 
                  switch(
                     ..3,
                     "tsv" = readr::read_tsv(..2),
                     "csv" = readr::read_csv(..2),
                     "xlsx" = readxl::read_xlsx(..2)
                  ),
               "unknown" = NA
            )
         ) %>% 
         purrr::set_names(fileList)
      
      # Reshape protein results selectively, as needed to ensure compatibility 
      # with functions later in the workflow
      
      raw_results_protein_reshaped <- 
         purrr::pmap(
            list(
               fileType,
               raw_results_protein
            ),
            ~switch(
               ..1,
               "tdreport" = 
                  ..2,
               "accessionlist" = 
                  ..2,
               "toppic" = 
                  reshape_toppic_protein(..2),
               "mspathfinder" = 
                  reshape_mspathfinder_protein(..2),
               "unknown" = 
                  NA
            )
         )
      
      ## raw_results_protein_full_reshaped is NOT DEFINED HERE
      ## because no reshaping needs to occur
      
      # Reshape proteoform results selectively, as needed to ensure  
      # compatibility with functions later in the workflow
      
      raw_results_proteoform_reshaped <- 
         purrr::pmap(
            list(
               fileType,
               raw_results_proteoform
            ),
            ~switch(
               ..1,
               "tdreport" = 
                  ..2,
               "accessionlist" = 
                  ..2,
               "toppic" = 
                  reshape_toppic_proteoform(..2),
               "mspathfinder" = 
                  reshape_mspathfinder_proteoform(..2),
               "unknown" = 
                  NA
            )
         )
      
      ## Process protein results ------------------------------------------------
      
      results_protein <-
         purrr::pmap(
            list(
               raw_results_protein_reshaped,
               fileList
            ),
            ~add_uniprot_info(..1, database = UPdatabase) %>% 
               get_GO_terms2(..2, go_locs_table) %>% 
               add_GRAVY() %>% 
               dplyr::mutate(
                  MonoisotopicMass = add_masses(SEQUENCE, monoisotopic = TRUE),
                  AverageMass = add_masses(SEQUENCE, monoisotopic = FALSE)
               ) %>% 
               add_fraction(assignments = fractionAssignments)
         )
      
      # Set names for results_protein
      
      names(results_protein) <-
         unlist(fileList) %>%
         basename()
      
      results_protein[[length(results_protein)+1]] <-
         get_locations_general(results_protein, go_locs_table)
      
      names(results_protein)[[length(results_protein)]] <-
         "SUMMARY"
      
      # Protein results, counts by fraction
      
      results_protein_countsbyfraction <-
         results_protein[1 : length(results_protein) - 1] %>%
         get_locations_byfraction2(go_locs_table)
      
      # Protein results, all hits
      # maybe this should be called proteoform allhits?
      
      results_protein_allhits <-
         raw_results_protein_full %>%
         purrr::map(add_GRAVY_allhits) %>%
         purrr::map(
            add_fraction,
            assignments = fractionAssignments
         ) %>%
         purrr::map(
            parse_mods_allhits,
            modification = tdreport_mods
         ) %>% 
         purrr::map_if(
            ~all(is.na(.x)),
            tibble::tibble
         )
      
      names(results_protein_allhits) <-
         unlist(fileList) %>%
         basename()
      
      # Proteoform results, all hits, hit counts
      # This is joined with results_proteoform later to include the hit counts
      # in the pform report
      
      results_proteoform_hitcounts <-
         purrr::discard(results_protein_allhits, ~all(is.na(.x))) %>% 
         purrr::map(
            ~dplyr::group_by(
               .x,
               filename,
               ProteoformRecordNum
            ) %>%
               dplyr::summarize(HitCount = dplyr::n()) %>%
               dplyr::ungroup()
         ) %>%
         purrr::reduce(dplyr::union_all)
      
      
      ## Process proteoform results ----------------------------------------------
      
      # For TDReports without proteoform record nums (i.e. current version of
      # ProSightPD) replace them with sequential numbers
      
      raw_results_proteoform_reshaped <- 
         purrr::pmap(
            list(
               fileType,
               raw_results_proteoform_reshaped
            ),
            ~switch(
               ..1,
               "tdreport" = 
                  replace_missing_PFR(..2),
               "accessionlist" = 
                  ..2,
               "toppic" = 
                  ..2,
               "mspathfinder" = 
                  ..2,
               "unknown" = 
                  ..2
            )
         )
      
      # Count all types of modifications in the results. ONLY WORKS
      # FOR TDREPORT FILES, which provides mod data in an easy-to-read
      # format
      
      results_proteoform_modcounts <-
         purrr::pmap(
            list(
               fileType,
               raw_results_proteoform_reshaped,
               fileList
            ),
            ~switch(
               ..1,
               "tdreport" = 
                  parse_mods_special(..2, modification = tdreport_mods) %>% 
                  dplyr::mutate(results_file_name = basename(..3)),
               NULL
            )
         ) %>%
         purrr::compact() %>% 
         purrr::reduce(dplyr::union_all)
      
      
      # Process raw proteoform results to FINAL FORM
      
      results_proteoform <-
         raw_results_proteoform_reshaped %>%
         purrr::map(
            add_uniprot_info,
            database = UPdatabase
         ) %>%
         purrr::map(
            add_fraction,
            assignments = fractionAssignments
         ) %>%
         purrr::map2(
            fileType,
            ~switch(
               .y,
               "tdreport" = 
                  parse_mods(
                     .x,
                     modification = tdreport_mods
                  ),
               .x
            )
         ) %>%
         purrr::map2(
            fileType,
            ~switch(
               .y,
               "tdreport" = 
                  dplyr::mutate(.x, ProteoformSequence_GRAVY = Peptides::hydrophobicity(ProteoformSequence)),
               "accessionlist" = 
                  .x,
               "toppic" = 
                  dplyr::mutate(.x, IntactProteinSequence_GRAVY = Peptides::hydrophobicity(SEQUENCE)),
               "mspathfinder" = 
                  dplyr::mutate(.x, ProteoformSequence_GRAVY = Peptides::hydrophobicity(Sequence))  
            )
         ) %>% 
         purrr::map_if(
            ~!all(is.na(.x)),
            ~dplyr::select(
               .x,
               -dplyr::any_of(
                  c(
                     "ExternalId",
                     "IsEndogenousCleavage",
                     "IsoformId",
                     "ChemicalProteoformId",
                     "AggregationLevel",
                     "HitId",
                     "IsSubsequence",
                     "PriorWeight",
                     "EntryId",
                     "ScoreForDecoy",
                     "ObservedPrecursorMassType",
                     "ResultSetId",
                     "DataFileId",
                     "IsActive",
                     "Creator",
                     "CreationDate"
                  )
               )
            )
         ) %>%
         purrr::map_if(
            ~!all(is.na(.x)),
            ~dplyr::select(
               .x,
               dplyr::any_of(
                  c(
                     "UNIPROTKB",
                     "ProteoformRecordNum",
                     "IntactSequence",
                     "ProteoformSequence"
                  )
               ),
               dplyr::everything()
            )
         ) %>% 
         purrr::map2(
            fileList,
            ~get_GO_terms2(
               .x,
               .y,
               go_locs_table
            )
         ) %>%
         purrr::map_if(
            ~!all(is.na(.x)),
            ~dplyr::left_join(.x, results_proteoform_hitcounts)
         )
      
      names(results_proteoform) <-
         unlist(fileList) %>%
         basename()
      
      results_proteoform[[length(results_proteoform)+1]] <-
         get_locations_general(results_proteoform, go_locs_table)
      
      names(results_proteoform)[[length(results_proteoform)]] <-
         "SUMMARY"
      
      
      # Save results ------------------------------------------------------------
      
      if (saveOutput == TRUE) {
         
         if (dir.exists(outputdir) == FALSE) dir.create(outputdir)
         
         ## Save protein results ------------
         
         for (i in seq_along(names(results_protein))) {
            
            names(results_protein)[i] <-
               stringr::str_replace_all(names(results_protein[i]), "[:punct:]", "")
            
            names(results_protein)[i] %<>%
               stringr::str_trunc(28, "left") %>% paste(i, "_", ., sep = "")
            
         }
         
         if (dir.exists(glue::glue("{outputdir}/protein_results")) == FALSE) {
            dir.create(glue::glue("{outputdir}/protein_results"))
         }
         
         resultsname <-
            glue::glue("{outputdir}/protein_results/{systime}_protein_results.xlsx")
         
         message(
            glue::glue("\nSaving protein results to {resultsname}")
         )
         
         results_protein %>%
            writexl::write_xlsx(path = resultsname)
         
         
         ## Save protein results, counts by fraction ------------
         
         if (dir.exists(glue::glue("{outputdir}/protein_results_countsbyfraction")) == FALSE) {
            dir.create(glue::glue("{outputdir}/protein_results_countsbyfraction"))
         }
         
         resultsname <-
            glue::glue(
               "{outputdir}/protein_results_countsbyfraction/{systime}_protein_countsbyfrac.xlsx"
            )
         
         
         results_protein_countsbyfraction %>%
            writexl::write_xlsx(path = resultsname)
         
         
         ## Save protein results, all hits ------------
         
         # Only run if at least one tdReport is included
         
         if (any(purrr::as_vector(fileType) == "tdreport")) {
            
            if (dir.exists(glue::glue("{outputdir}/protein_results_allhits")) == FALSE) {
               dir.create(glue::glue("{outputdir}/protein_results_allhits"))
            }
            
            fileList %>%
               purrr::map(basename) %>%
               purrr::map(tools::file_path_sans_ext) %>%
               glue::glue_data("{outputdir}/protein_results_allhits/{.}_allhits.xlsx") %>%
               as.list() %>%
               purrr::walk2(
                  results_protein_allhits,
                  ~writexl::write_xlsx(.y, path = .x)
               )
            
         }
         
         ## Save proteoform results ------------
         
         for (i in seq_along(names(results_proteoform))) {
            
            names(results_proteoform)[i] <-
               stringr::str_replace_all(names(results_proteoform[i]), "[:punct:]", "")
            
            names(results_proteoform)[i] %<>%
               stringr::str_trunc(28, "left") %>% paste(i, "_", ., sep = "")
            
         }
         
         if (dir.exists(glue::glue("{outputdir}/proteoform_results")) == FALSE) {
            dir.create(glue::glue("{outputdir}/proteoform_results"))
         }
         
         resultsname <-
            glue::glue("{outputdir}/proteoform_results/{systime}_proteoform_results.xlsx")
         
         message(
            glue::glue("\nSaving proteoform results to {resultsname}")
         )
         
         purrr::map(
            results_proteoform,
            ~{if (all(is.na(.x))) tibble::tibble() else .x}
         ) %>% 
            writexl::write_xlsx(path = resultsname)
         
         
      }
      
      
      # Get result parameters ---------------------------------------------------
      
      # Only run if at least one tdReport is included
      
      if (any(purrr::as_vector(fileType) == "tdreport")) {
         
         results_resultparameters <-
            purrr::map2(
               fileType,
               fileList,
               ~switch(
                  .x,
                  "tdreport" =
                     get_result_parameters(.y) %>%
                     dplyr::mutate(results_file_name = basename(.y)),
                  NULL
               )
            ) %>%
            purrr::reduce(dplyr::union_all)
         
      }
      
      
      # Make Dashboard ----------------------------------------------------------
      
      if (makeDashboard == TRUE) {
         
         if (dir.exists(outputdir) == FALSE) {
            dir.create(outputdir)
         }
         
         if (dir.exists(glue::glue("{outputdir}/report")) == FALSE) {
            dir.create(glue::glue("{outputdir}/report"))
         }
         
         
         # Copy folders to temp output directory and knit there to avoid file
         # permission problems in shiny/shinyapps
         
         
         fs::dir_copy(
            system.file(
               "rmd",
               package = "GUPPI"
            ),
            fs::path(
               outputdir,
               "rmd"
            ),
            overwrite = TRUE
         )
         
         fs::dir_copy(
            system.file(
               "fonts",
               package = "GUPPI"
            ),
            fs::path(
               outputdir,
               "fonts"
            ),
            overwrite = TRUE
         )
         
         fs::dir_copy(
            system.file(
               "css",
               package = "GUPPI"
            ),
            fs::path(
               outputdir,
               "css"
            ),
            overwrite = TRUE
         )
         
         rmarkdown::render(
            fs::path(
               outputdir,
               "rmd",
               "generate_dashboard_parent.Rmd"
            ),
            output_file =
               dashboardPath
         )
         
         fs::dir_delete(
            fs::path(
               outputdir,
               "rmd"
            )
         )
         
         fs::dir_delete(
            fs::path(
               outputdir,
               "fonts"
            )
         )
         
         fs::dir_delete(
            fs::path(
               outputdir,
               "css"
            )
         )
         
      }
      
      
      if (saveOutput == TRUE) {
         
         ## Get run time and message using PushBullet
         
         totaltime <-
            capture.output(tictoc::toc()) %>%
            stringr::str_extract("[0-9]+") %>%
            as.numeric() %>%
            `/`(60) %>%
            round(digits = 2)
         
         message(paste0("\nElapsed time: ", totaltime, " min"))
         
         # Save Session Info ------------------------------------------------------
         
         # Session info for every run is saved to a txt file in the
         # output directory, in case
         
         if (dir.exists(glue::glue("{outputdir}/session_info")) == FALSE) {
            dir.create(glue::glue("{outputdir}/session_info"))
         }
         
         sessioninfo::session_info() %>%
            capture.output() %>%
            writeLines(
               glue::glue("{outputdir}/session_info/{systime}_sessionInfo.txt")
            )
         
      }
      
   }
