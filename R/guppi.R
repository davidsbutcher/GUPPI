
#' Get UniProt Protein Info (GUPPI)
#'
#' @description
#' guppi() analyzes a .tdReport file generated by TDPortal or ProSightPD and adds 
#' additional data from UniProt.
#' 
#' @param filedir Character vector of the directory which contains the input file(s). Files can be at 
#' any level below the directory, subdirectories are checked recursively.
#' @param filename Character vector of the names of the tdReport files, including extension. 
#' Must match the name of the files exactly.
#' @param taxonNumber Numeric vector. NCBI taxon number to be used for getting UniProt data, 
#' e.g. 83333 for E. coli K12.
#' @param GOLocType Name of taxon to use for determination of subcellular locations. 
#' Acceptable values are "bacteria" and "eukaryota".
#' @param fractionAssignments Optional argument. A named list with names set to 
#' the fraction numbers of the input files and values set to the input file names. 
#' If left blank, GUPPI will attempt to assign fraction numbers automatically from 
#' file names in the tdReport.
#' @param outputdir Character vector. Directory to use for output, files will be 
#' saved to subdirectories. Directory will be created if it doesn't exist, as long 
#' as parent directory exists.
#' @param fdr False detection rate cutoff for protein and proteoform identifications. 
#' Defaults to 0.01 (1\%).
#' @param saveOutput Boolean value. Controls whether protein report, proteoform 
#' report, etc. are saved to output directory. Doesn't effect GUPPI report. 
#' Defaults to TRUE.
#' @param makeDashboard Boolean value. Controls whether GUPPI report is rendered 
#' to the output directory. Defaults to FALSE.
#' @param staticDashboard Boolean value. Controls whether the dashboard should be
#' generated with dynamic visualization based on Plotly or with static images.
#' @param dashboardPath Full path and name of dashboard output (i.e. GUPPI report). 
#' Defaults to /report subdirectory of the output directory.
#' 
#' @return
#' This function is called for its side effects, i.e. the files in the output
#' directory.
#'
#' @export
#'
#' @examples
#' \dontrun{
#'     GUPPI::guppi(
#'        "C:/Users/David Butcher/TDReports",
#'        c(
#'           "20200420_Excellent_TDReport_01.tdReport",
#'           "20200420_Excellent_TDReport_02.tdReport"
#'        ),
#'        83333,
#'        GOLocType = "bacteria",
#'        fractionAssignments = NULL,
#'        outputdir = "C:/Users/David Butcher/guppi_output",
#'        fdr = 0.01,
#'        saveOutput = TRUE,
#'        makeDashboard = TRUE
#'     )
#' }

guppi <-
   function(
      filedir,
      filename,
      taxonNumber,
      GOLocType = "bacteria",
      fractionAssignments = NULL,
      outputdir,
      fdr = 0.01,
      saveOutput = TRUE,
      makeDashboard = FALSE,
      staticDashboard = FALSE,
      dashboardPath = glue::glue(
         "{outputdir}/report/{format(Sys.time(), '%Y%m%d_%H%M%S')}_dashboard.html"
      )
   ) {
      
      # Assertions --------------------------------------------------------------
      
      assertthat::assert_that(
         assertthat::is.dir(filedir),
         msg = "filedir is not a recognized path"
      )
      
      purrr::map_chr(
         filename,
         ~assertthat::assert_that(
            assertthat::is.string(.x),
            msg = "A filename is not a string"
         )
      )
      
      assertthat::assert_that(
         assertthat::is.number(taxonNumber),
         msg = "taxonNumber is not a number"
      )
      
      assertthat::assert_that(
         GOLocType == "bacteria" | GOLocType == "eukaryota",
         msg = "GOLocType must be 'bacteria' or 'eukaryota'"
      )
      
      assertthat::assert_that(
         assertthat::is.dir(dirname(outputdir)),
         msg = "outputdir parent is not a recognized path"
      )
      
      assertthat::assert_that(
         assertthat::is.number(fdr) & fdr > 0 & fdr <= 1,
         msg = "fdr should be a number between 0 and 1"
      )
      
      assertthat::assert_that(
         assertthat::is.flag(makeDashboard),
         msg = "makeDashboard should be TRUE or FALSE"
      )
      
      assertthat::assert_that(
         assertthat::is.flag(staticDashboard),
         msg = "staticDashboard should be TRUE or FALSE"
      )
      
      assertthat::assert_that(
         assertthat::is.dir(fs::path_dir(dashboardPath)),
         msg = "dashboardPath parent is not a recognized path"
      )
      
      
      
      ## Check file extensions ------------------------------------------------
      
      filelist <-
         get_data_path(
            filedir,
            filename,
            tools::file_ext(filename)
         )
      
      extension <-
         filelist %>%
         purrr::map(tools::file_ext)
      
      assertthat::assert_that(
         assertthat::assert_that(
            length(unique(extension)) <= 1
         ),
         msg = "More than one file extension present. Only one type of file is allowed."
      )
      
      assertthat::assert_that(
         assertthat::assert_that(
            length(extension) != 0
         ),
         msg = "No acceptable input files. Only tdReport, csv, or xlsx are allowed."
      )
      
      # Check for allowed extensions, case insensitive
      
      allowed_extensions <- c("tdReport", "csv", "tsv", "xlsx")
      
      assertthat::assert_that(
         purrr::map_chr(
            extension,
            ~stringr::str_detect(
               .x, fixed(allowed_extensions, ignore_case = TRUE)
            ) %>% 
               any()
         ) %>% 
            as.logical() %>% 
            all(),
         msg = 
            paste0(
               "All extensions must be one of",
               paste(allowed_extensions, collapse = ", ")
            )
      )
      
      # Load input files --------------------------------------------------------
      
      # Start timer
      
      tictoc::tic()
      
      ## Load/download UniProt database ------------------------------------------
      
      # Check for predownloaded UP database
      
      if (
         file.exists(
            system.file(
               "extdata",
               "UPdatabase",
               paste0(taxonNumber, "_full_UniProt_database.rds"),
               package = "GUPPI"
            )
         )
      ) {
         
         message(
            glue::glue(
               "\nLoading UniProt database for taxon {taxonNumber} from package directory"
            )
         )
         
         UPdatabase <-
            readRDS(
               system.file(
                  "extdata",
                  "UPdatabase",
                  paste0(taxonNumber, "_full_UniProt_database.rds"),
                  package = "GUPPI"
               )
            )
         
      } else {
         
         UPdatabase <-
            download_UP_database(
               taxonNumber,
               saveUPdata = TRUE
            )
         
      }
      
      
      ## Load GO locations correlation table -------------------------------------
      
      # Load file containing locations corresponding to
      # GO terms, either bacteria or eukaryota
      
      if (GOLocType == "bacteria") {
         
         go_locs_table <-
            read.csv(
               system.file(
                  "extdata",
                  "GO_cellular_component_taxon2_bacteria.csv",
                  package = "GUPPI"
               )
            )
         
      } else if (GOLocType == "eukaryota") {
         
         go_locs_table <-
            read.csv(
               system.file(
                  "extdata",
                  "GO_cellular_component_taxon2759_eukaryota.csv",
                  package = "GUPPI"
               )
            )
         
      }
      
      
      ## Load modifications data ----------------------------------------------
      
      # Load file containing all the PTM information from TDreport
      # (sourced from UniMod, PSI-MOD, etc.)
      
      tdreport_mods <-
         readRDS(
            system.file(
               "extdata",
               "tdreport_mods_table.rds",
               package = "GUPPI"
            )
         )
      
      # Run analysis ---------------------------------------------------------------------------------
      
      # Save start time to variable for use in output filenames
      
      systime <- format(Sys.time(), "%Y%m%d_%H%M%S")
      
      ## Read Data Files -----------------------------------------------------------------------------
      
      # XXX NEED NEW FUNCTION HERE TO READ INPUT FILES AND GET ITS TYPE! THEN 
      # SWITCH STATEMENT TO CHOOSE FUNCTIONS FOR READING??
      
      
       
      if (extension[[1]] == "csv") {
         
         message("Reading csv files...")
         
         proteinlist  <-
            filelist %>%
            purrr::map(readr::read_csv)
         
         tdreport_file <- FALSE
         
      } else if (extension[[1]] == "xlsx") {
         
         message("Reading xlsx files...")
         
         proteinlist  <-
            filelist %>%
            purrr::map(readxl::read_xlsx)
         
         tdreport_file <- FALSE
         
      } else if (extension[[1]] == "tdReport") {
         
         message("\nReading protein data from tdReport\n")
         
         proteinlist <-
            filelist %>%
            purrr::map(
               read_tdreport_protein,
               fdr_cutoff = fdr
            )
         
         message("\nReading full protein data from tdReport\n")
         
         proteinlistfull <-
            filelist %>%
            purrr::map(
               read_tdreport_protein_full,
               fdr_cutoff = fdr
            )
         
         message("\nReading proteoform data from tdReport\n")
         
         proteoformlist <-
            filelist %>%
            purrr::map(
               read_tdreport_proteoform,
               fdr_cutoff = fdr
            )
         
         tdreport_file <- TRUE
         
      } else {
         
         stop("No acceptable input files. Only tdReport, csv, or xlsx are allowed.")
         
      }
      
      names(proteinlist) <- filelist
      
      ## Process protein results ------------------------------------------------
      
      results_protein <-
         proteinlist %>%
         purrr::map(
            add_uniprot_info,
            database = UPdatabase,
            tdrep = tdreport_file
         ) %>%
         purrr::map2(filelist, get_GO_terms2, go_locs_table) %>%
         purrr::map(add_GRAVY) %>%
         purrr::map(add_masses) %>%
         purrr::map(
            add_fraction,
            assignments = fractionAssignments
         )
      
      names(results_protein) <-
         unlist(filelist) %>%
         basename()
      
      results_protein[[length(results_protein)+1]] <-
         get_locations_general(results_protein, go_locs_table)
      
      names(results_protein)[[length(results_protein)]] <-
         "SUMMARY"
      
      # Protein results, counts by fraction
      
      results_protein_countsbyfraction <-
         results_protein[1 : length(results_protein) - 1] %>%
         get_locations_byfraction2(go_locs_table)
      
      # Protein results, all hits
      # maybe this should be called proteoform allhits?
      
      results_protein_allhits <-
         proteinlistfull %>%
         purrr::map(add_GRAVY_allhits) %>%
         purrr::map(
            add_fraction,
            assignments = fractionAssignments
         ) %>%
         purrr::map(parse_mods_allhits, modification = tdreport_mods)
      
      names(results_protein_allhits) <-
         unlist(filelist) %>%
         basename()
      
      # Proteoform results, all hits, hit counts
      # This is joined with results_proteoform later to include the hit counts
      # in the pform report
      
      results_proteoform_hitcounts <-
         results_protein_allhits %>%
         purrr::map(
            ~dplyr::group_by(
               .x,
               filename,
               ProteoformRecordNum
            ) %>%
               dplyr::summarize(HitCount = dplyr::n()) %>%
               dplyr::ungroup()
         ) %>%
         purrr::reduce(dplyr::union_all)
      
      
      ## Process proteoform results ----------------------------------------------
      
      # For TDReports without proteoform record nums (i.e. current version of
      # ProSightPD) replace them with sequential numbers
      
      proteoformlist <-
         proteoformlist %>%
         purrr::map(
            ~dplyr::filter(.x, IntactSequence != "DECOY") %>%
               {
                  if (all(.$ProteoformRecordNum) == 0) {
                     dplyr::mutate(
                        .,
                        ProteoformRecordNum =
                           seq_len(length(.$ProteoformRecordNum))
                     )
                  } else {.}
               }
         )
      
      if (all(proteoformlist$ProteoformRecordNum) == 0) {
         
         proteoformlist <-
            proteoformlist %>%
            dplyr::mutate(
               ProteoformRecordNum =
                  seq_len(length(proteoformlist$ProteoformRecordNum))
            )
         
      }
      
      results_proteoform_modcounts <-
         proteoformlist %>%
         purrr::map(
            ~parse_mods_special(.x, modification = tdreport_mods)
         ) %>%
         purrr::map2(
            filelist,
            ~dplyr::mutate(.x, tdreport_name = basename(.y))
         ) %>%
         purrr::reduce(dplyr::union_all)
      
      results_proteoform <-
         proteoformlist %>%
         purrr::map(
            add_uniprot_info,
            database = UPdatabase,
            tdrep = TRUE
         ) %>%
         purrr::map(
            add_fraction,
            assignments = fractionAssignments
         ) %>%
         purrr::map(
            parse_mods,
            modification = tdreport_mods
         ) %>%
         purrr::map(
            ~dplyr::mutate(
               .x,
               GRAVY = Peptides::hydrophobicity(ProteoformSequence)
            )
         ) %>%
         purrr::map(
            ~{if (!"IsEndogenousCleavage" %in% names(.x)) dplyr::mutate(.x, IsEndogenousCleavage = NA) else .x} %>%
               {if (!"IsSubsequence" %in% names(.)) dplyr::mutate(., IsSubsequence = NA) else .} %>%
               {if (!"PriorWeight" %in% names(.)) dplyr::mutate(., PriorWeight = NA) else .} %>%
               dplyr::select(
                  -ExternalId,
                  -IsEndogenousCleavage,
                  -IsoformId,
                  -ChemicalProteoformId,
                  -AggregationLevel,
                  -HitId,
                  -IsSubsequence,
                  -PriorWeight,
                  -EntryId,
                  -ScoreForDecoy,
                  -ObservedPrecursorMassType,
                  -ResultSetId,
                  -DataFileId,
                  -IsActive,
                  -Creator,
                  -CreationDate,
                  -SEQUENCE
               )
         ) %>%
         purrr::map(
            ~dplyr::select(
               .x,
               UNIPROTKB,
               ProteoformRecordNum,
               IntactSequence,
               ProteoformSequence,
               dplyr::everything()
            )
         ) %>%
         purrr::map2(filelist, get_GO_terms2, go_locs_table) %>%
         purrr::map(
            ~dplyr::left_join(.x, results_proteoform_hitcounts)
         )
      
      names(results_proteoform) <-
         unlist(filelist) %>%
         basename()
      
      results_proteoform[[length(results_proteoform)+1]] <-
         get_locations_general(results_proteoform, go_locs_table)
      
      names(results_proteoform)[[length(results_proteoform)]] <-
         "SUMMARY"
      
      
      # Save results ------------------------------------------------------------
      
      if (saveOutput == TRUE) {
         
         if (dir.exists(outputdir) == FALSE) dir.create(outputdir)
         
         ## Save protein results ------------
         
         for (i in seq_along(names(results_protein))) {
            
            names(results_protein)[i] <-
               stringr::str_replace_all(names(results_protein[i]), "[:punct:]", "")
            
            names(results_protein)[i] %<>%
               stringr::str_trunc(28, "left") %>% paste(i, "_", ., sep = "")
            
         }
         
         if (dir.exists(glue::glue("{outputdir}/protein_results")) == FALSE) {
            dir.create(glue::glue("{outputdir}/protein_results"))
         }
         
         resultsname <-
            glue::glue("{outputdir}/protein_results/{systime}_protein_results.xlsx")
         
         message(
            glue::glue("\nSaving protein results to {resultsname}")
         )
         
         results_protein %>%
            writexl::write_xlsx(path = resultsname)
         
         
         ## Save protein results, counts by fraction ------------
         
         if (dir.exists(glue::glue("{outputdir}/protein_results_countsbyfraction")) == FALSE) {
            dir.create(glue::glue("{outputdir}/protein_results_countsbyfraction"))
         }
         
         resultsname <-
            glue::glue(
               "{outputdir}/protein_results_countsbyfraction/{systime}_protein_countsbyfrac.xlsx"
            )
         
         
         results_protein_countsbyfraction %>%
            writexl::write_xlsx(path = resultsname)
         
         
         ## Save protein results, all hits ------------
         
         
         if (dir.exists(glue::glue("{outputdir}/protein_results_allhits")) == FALSE) {
            dir.create(glue::glue("{outputdir}/protein_results_allhits"))
         }
         
         filelist %>%
            purrr::map(basename) %>%
            purrr::map(tools::file_path_sans_ext) %>%
            glue::glue_data("{outputdir}/protein_results_allhits/{.}_allhits.xlsx") %>%
            as.list() %>%
            purrr::walk2(
               results_protein_allhits,
               ~writexl::write_xlsx(.y, path = .x)
            )
         
         ## Save proteoform results ------------
         
         for (i in seq_along(names(results_proteoform))) {
            
            names(results_proteoform)[i] <-
               stringr::str_replace_all(names(results_proteoform[i]), "[:punct:]", "")
            
            names(results_proteoform)[i] %<>%
               stringr::str_trunc(28, "left") %>% paste(i, "_", ., sep = "")
            
         }
         
         if (dir.exists(glue::glue("{outputdir}/proteoform_results")) == FALSE) {
            dir.create(glue::glue("{outputdir}/proteoform_results"))
         }
         
         resultsname <-
            glue::glue("{outputdir}/proteoform_results/{systime}_proteoform_results.xlsx")
         
         message(
            glue::glue("\nSaving proteoform results to {resultsname}")
         )
         
         results_proteoform %>%
            writexl::write_xlsx(path = resultsname)
         
         
      }
      
      
      # Get result parameters ---------------------------------------------------
      
      results_resultparameters <-
         purrr::map(
            filelist,
            ~get_result_parameters(.x) %>%
               dplyr::mutate(tdreport_name = basename(.x))
         ) %>%
         purrr::reduce(dplyr::union_all)
      
      
      # Make Dashboard ----------------------------------------------------------
      
      if (makeDashboard == TRUE) {
         
         if (dir.exists(outputdir) == FALSE) {
            dir.create(outputdir)
         }
         
         if (dir.exists(glue::glue("{outputdir}/report")) == FALSE) {
            dir.create(glue::glue("{outputdir}/report"))
         }
         
         
         # Copy folders to temp output directory and knit there to avoid file
         # permission problems in shiny/shinyapps
         
         
         fs::dir_copy(
            system.file(
               "rmd",
               package = "GUPPI"
            ),
            fs::path(
               outputdir,
               "rmd"
            ),
            overwrite = TRUE
         )
         
         fs::dir_copy(
            system.file(
               "fonts",
               package = "GUPPI"
            ),
            fs::path(
               outputdir,
               "fonts"
            ),
            overwrite = TRUE
         )
         
         fs::dir_copy(
            system.file(
               "css",
               package = "GUPPI"
            ),
            fs::path(
               outputdir,
               "css"
            ),
            overwrite = TRUE
         )
         
         rmarkdown::render(
            fs::path(
               outputdir,
               "rmd",
               "generate_dashboard_parent.Rmd"
            ),
            output_file =
               dashboardPath
         )
         
         fs::dir_delete(
            fs::path(
               outputdir,
               "rmd"
            )
         )
         
         fs::dir_delete(
            fs::path(
               outputdir,
               "fonts"
            )
         )
         
         fs::dir_delete(
            fs::path(
               outputdir,
               "css"
            )
         )
         
      }
      
      
      if (saveOutput == TRUE) {
         
         ## Get run time and message using PushBullet
         
         totaltime <-
            capture.output(tictoc::toc()) %>%
            stringr::str_extract("[0-9]+") %>%
            as.numeric() %>%
            `/`(60) %>%
            round(digits = 2)
         
         message(paste0("\nElapsed time: ", totaltime, " min"))
         
         # Save Session Info ------------------------------------------------------
         
         # Session info for every run is saved to a txt file in the
         # output directory, in case
         
         if (dir.exists(glue::glue("{outputdir}/session_info")) == FALSE) {
            dir.create(glue::glue("{outputdir}/session_info"))
         }
         
         sessioninfo::session_info() %>%
            capture.output() %>%
            writeLines(
               glue::glue("{outputdir}/session_info/{systime}_sessionInfo.txt")
            )
         
      }
      
   }
